\section{L'ingénierie des besoins}



\subsection{Introduction}
On doit capturer les besoins du client. On doit savoir comment l’informatique va résoudre ses problèmes. C’est souvent à cause de cette étape que des projets tombent à l’eau.



\subsection{Les besoins}
Les besoins décrive le système et ses contraintes.
\\C’est ce que le programme doit faire mais pas comment il va le faire.



\subsubsection{User et System Requirements}
\begin{description}
	\item [User requirements] Ce que l’utilisateur veut.
	\item [System requirements] Un peu plus bas, plus formel.
\end{description}
Les users requirements doivent être dans le jargon du client.



\subsubsection{Besoins fonctionnels ou non}
\begin{description}
	\item [Besoins fonctionnels] Les services que l’application doit rendre.
	\item [Besoins non-fonctionnels] ergonomie, robustesse, sécurité, …
	\item [Domain requirements] Vient du domaine dans lequel l’application sera utilisée. Ces besoins ne seront pas donné par le clients car ils sont évidents pour lui.
\end{description}



\subsection{Écrire les besoins}
Il faut écrire les besoins pour que d’autres personnes puissent les lire. Ces documents vont devoir être simple et clair.
\\Il faut numéroter les besoins avec des titres,sous-titres, … et éviter les gros pavés de texte.
\\Il faut se définir un standard. Il faut aussi éviter le jargon informatique car le client va le lire aussi.



\subsection{Les System requirements}
Il faut être plus rigoureux que pour les user requirements. UML peut intervenir ici.
On définit les terminologie, on remplace le jargon par des définitions, … On a aussi une table des matière.
\\\textbf{Software requirements document}: Il s’agit du document qui regroupe les user requirements et les system requirements. Il existe des standards pour ce genre de document.



\subsection{Croiser les besoins}
Différentes personnes pensent différemment. Pour chaque besoins, il faut chercher les informations. On va souvent tomber sur des contradictions.
Certaines personnes pourrait vouloir freiner le projet.
\\Il ne faut pas non plus oublier d’aller voir les utilisateurs.



\subsection{Aperçu d’un SRD}
On commence par l’introduction. On y explique les buts à atteindre.
\\Le SRD va évoluer au fur et à mesure du projets.
\\Il faut donc un gestionnaire de version pour avoir un historique des versions et on peut récupérer les anciennes.



\subsection{UML Use case}
La vue des use case est centrale en UML car ce sont les besoins qui définissent le programme.
On l’utilise pour exprimer des interactions, pas des contraintes donc elle est mieux pour les besoins fonctionnels.



\subsubsection{Les acteurs}
On représente ça par un bonhomme dans tous les cas. Il ne s’agit pas spécialement d’une personne. C’est les acteurs qui déclenche les use case.



\subsubsection{Les use cases}
Il s’agit d’un ensemble d’action que fait le système. Ils sont initiées par un acteur et lui fournissent une réponse.
\\On ne dit pas ce qui se passe derrière, seulement les informations qui entrent et qui sortent.
\\On peut décrire l’use case sous forme de texte structuré ou sous forme de diagrammes de séquence ou des diagrammes d’état.
\\On peut décrire les exceptions, les erreurs, les scénarios alternatifs, …


\subsubsection{Description de l’use case}
Généralement sous forme de texte.
\begin{itemize}
	\item Acteurs ;
	\item Pré-conditions ( ce qui est vrai avant que le use case se déclenche ) ;
	\item Post-conditions ( ce qui est vrai après le use case ) ;
	\item Cas basique ( décrit chaque étape de l’interaction entre le système et l’utilisateur ) ;
	\item Alternative flow ;
	\item Special requierement ( Besoins spéciaux du use case ) ;
	\item Relation entre use cas.
\end{itemize}



\subsubsection{Relations}
\begin{description}
	\item [Généralisation entre les acteurs] Permettre à des acteurs d’hériter d’autre.
	\item [Généralisation d’use-case] Permet de spécialiser un use case.
	\item [Include] Permet d’inclure le contenu d’un use case dans un autre. ( on représente ca avec le stéréotype << include >>.
	\item [Extensibilité] Revient à décrire un use case en laissant un vide.
\end{description}



\subsection{Modélisation dynamique}
Ce qu’on a vu avant = Modélisation statique => On définit les choses.
\\Maintenant on s’intéresse au côté dynamique comme l’envoi de messages entre objets, leur vie, …
\\On ne modélise pas tout mais seulement le nécessaire.
\\UML offre 4 diagrammes: Sequence digrams, collaboration digrams, state diagrams, activity diagrams.

\subsubsection{Sequence diagrams}
Les diagrammes de séquence et de collaboration montrent tous les deux de la collaboration mais celui de séquence se concentre sur le temps alors que celui de collaboration se concentre sur la structure de communication.
\\Le séquence diagramme représente l'interaction entre plusieurs objets comme une séquence de message se lisant du haut vers le bas.
\\On peut utiliser des branchements, des boucles, des conditions, …
\\L’échange de message se fait de manière synchrone (flèche pleine), asynchrone (flèche pas pleine) et la réponse (flèche pointillée).
\\On peut envoyé un message new peut être envoyé à un objet qu’on crée. Quand on a fini on le delete en plaçant une croix à la fin de sa ligne de vie.

\subsubsection{Collaboration diagrams}
Parfois on a trop d’objet et le diagramme de séquence deviendrait trop complexe.
\\On utilise donc le diagramme de collaboration où la notion de temps disparaît
\\On peut numéroter les messages, pour savoir dans quel ordre ils sont envoyé.
\\On peut mettre des conditions et des descriptions.
\\La visibilité permet de savoir comment un objet sait qu’un autre existe.

\begin{description}
	\item [Association] Le réceptionniste est un attribut
	\item [Global] Variable global
	\item [Local] Variable local
	\item [Parameter] Objet recu en paramètre.
	\item [Self] Le pointeur this.
\end{description}